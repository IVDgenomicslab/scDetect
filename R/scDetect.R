##scDetect

## scDetect
## A gene expression rank-based ensemble cell type classification method
##
## Identification of cell types aided by gene expression rank-based ensemble method
##


#' @import ROCR
#' @import caret
#' @import caTools
#' @import preprocessCore
#' @import rJava
#' @import RWeka
#' @import RWekajars
#' @import mlbench
#' @import ROSE
#' @Depends switchBox
#' @import pROC
#' @importFrom switchBox SWAP.Train.KTSP
#' @import clusterProfiler
#' @import org.Hs.eg.db
#' @import AUCell
#' @import Seurat
#' @import infercnv
#' @import ConsensusClusterPlus
#' @import switchBox

require(switchBox)


#########################
#get feature genes#
#results is feature_list#
#########################
#' @title Get feature genes from a training dataset
#' @description Get feature genes from a training dataset for \code{scDetect} cell type classification.
#' @param train_set_matrix A matrix object with genes as rows and cells as columns.
#' @param train_set_lable A vector object with cell type lables of the cells in train_set_matrix.
#' @return A vector object with the feature genes
#' @export
#' @author
#' Yifei Shen
#' @examples
#'
#' # Get feature genes from a training dataset
#'
#' feaure_genes <- getFeature(train_set_matrix = train_set_matrix, train_set_lable = train_set_lable)
#'

getFeature<-function(train_set_matrix,train_set_lable){
  require(switchBox)
  cell_type<-as.data.frame(table(train_set_lable))

  if(length(which(cell_type$Freq==0))!=0){
    cell_type<-cell_type$train_set_lable[-which(cell_type$Freq==0)]
  }
  cell_type<-cell_type$train_set_lable
  cell_type<-as.character(cell_type)

  feature_list<-c()

  #mad filter
  #print("MAD")
  mads=apply(train_set_matrix,1,mad)
  train_set_matrix=train_set_matrix[rev(order(mads))[1:5000],]


  for(w in 1:length(cell_type)){
    new_labl<-train_set_lable
    new_labl<-as.character(new_labl)
    new_labl[which(new_labl != cell_type[w])]<-"other"
    new_labl<-as.factor(new_labl)

    for(r in 1:3){
      set.seed(r)
      ctp<-which(train_set_lable == cell_type[w])
      random_other<-which(train_set_lable != cell_type[w])
      random_index<-sample(1:length(random_other),length(ctp),replace=T)

      mix<-c(ctp,random_index)

      classifier <- SWAP.Train.KTSP(train_set_matrix[,mix], new_labl[mix])
      classifier$TSPs->getTSP

      getTSP<-as.character(getTSP)

      feature_list<-c(feature_list,getTSP)

    }


  }

  feature_list<-unique(feature_list)

  return(feature_list)
}




#######################################################################
#get cutoff value #cutoff two Intermediate cell type# cutoff unknown##
#get unknown cut off based on permutation#
#######################################################################
#' @title Get cutoff value for scDetect
#' @description Get Intermediate-type cutoff value and Unknown cell type cutoff value based on permutation for the scDetect score.
#' @param train_set_matrix A matrix object with genes as rows and cells as columns.
#' @param train_set_lable A vector  object with cell type lables of the cells in train_set_matrix.
#' @param feature_list A vector  object with the feature genes generated by \code{getFeature}.
#' @return A list object with cutoff for Intermediate cell type, and cutoff for Unknown cell type.
#' @export
#' @author
#' Yifei Shen
#' @examples
#'
#' # Get cutoff value for scDetect
#'
#' cutoff_results <- getCutoff(train_set_matrix,train_set_lable,feature_list)
#'

getCutoff<-function(train_set_matrix,train_set_lable,feature_list=NULL){



  test_data<-train_set_matrix[feature_list,]

  ###random
  ran_id<-sample(1:length(feature_list),length(feature_list),replace = F)

  test_data_new<-test_data[ran_id,]

  rownames(test_data_new)<-rownames(test_data)

  #########################
  random_matrix<-array(data=NA,c(1000,length(feature_list)))

  for(k in 1:1000){

    ran_id<-sample(1:length(feature_list),length(feature_list),replace = T)

    random_matrix[k,]<-ran_id

  }

  ran_sampid<-sample(1:ncol(train_set_matrix),1000,replace = T)
  test_data_new<-test_data[,ran_sampid]

  for(w in 1:ncol(test_data_new)){
    test_data_new[,w]<-test_data_new[random_matrix[w,],w]

  }


  predict_results<-scDetect_score(test_data_new,train_set_matrix,train_set_lable,feature_list)

  random_score<-predict_results$predict_score
  random_score<-random_score[order(random_score,decreasing = T)]
  unknown_cut<-random_score[round(ncol(test_data_new)*0.05,0)]


  cell_type_num<-nrow(as.data.frame(table(train_set_lable)))

  two_cell_type_cutoff<-0.2/cell_type_num

  unknown_cut<-round(unknown_cut,3)
  two_cell_type_cutoff<-round(two_cell_type_cutoff,3)


  all_cutoff <- list(unknown_cutoff = unknown_cut, two_cell_type_cutoff = two_cell_type_cutoff,random_score=random_score)

  return(all_cutoff)


  return()

}




############################################################
#scDetect_new include Unknown and two cancer type option#
#get list results #1# predict_lable #2#new_predict #3#final_predict
############################################################
#' @title Calculate scDetect-score
#' @description Calculate scDetect-score for \code{scDetect} prediction.
#' @param vali_set_matrix A matrix object with genes as rows and cells as columns.
#' @param train_set_matrix A matrix object with genes as rows and cells as columns.
#' @param train_set_lable A list object with cell type lables of the cells in train_set_matrix.
#' @param feature_list A list object with the feature genes generated by \code{getFeature}.
#' @return A list object with predict_lable and predict_score
#' @export
#' @author
#' Yifei Shen
#' @examples
#'
#' # Calculate scDetect-score
#'
#'
#' scDetect_score_results <- scDetect_score(vali_set_matrix,train_set_matrix,train_set_lable,feature_list)
#'

scDetect_score<-function(vali_set_matrix,train_set_matrix,train_set_lable,feature_list=NULL){

  ####transfer data####
  if(!is.null(feature_list)){
    cnam<-as.character(train_set_lable)
    gdy_filt<-train_set_matrix[feature_list,]
    braina<-vali_set_matrix[feature_list,]
  }

  if(is.null(feature_list)){

    cnam<-as.character(train_set_lable)
    gdy_filt<-train_set_matrix
    braina<-vali_set_matrix


  }
  #####################

  #cell type number
  namtabz<-as.data.frame(table(train_set_lable))
  namtabz<-namtabz[which(namtabz$Freq!=0),]
  namtabz<-namtabz[,1]
  namtabz<-as.character(namtabz)
  ctn<-length(namtabz)

  #cell sample number
  csn<-length(train_set_lable)
  csn_test<-ncol(vali_set_matrix)

  #make the cell pairs matrix##
  rn<-ctn*(ctn-1)/2
  cancer_pairs_matrix<-array(dim=c(rn,2))
  row_num<-vector()
  count<-1
  for(i in 1:(ctn-1)){
    namtabz[i]->typea
    numb<-i+1
    for(k in numb:ctn){
      cancer_pairs_matrix[count,1]<-typea
      cancer_pairs_matrix[count,2]<-namtabz[k]
      rnames<-paste(typea,namtabz[k],sep=" VS ")
      row_num<-c(row_num,rnames)
      count<-count+1
    }
  }
  rownames(cancer_pairs_matrix)<-row_num
  #make the cell pairs matrix END##



  #for each cell pairs
  cancer_type_accuracy<-array(dim=c(rn,csn_test))
  rownames(cancer_type_accuracy)<-row_num
  cancer_type_score<-array(dim=c(rn,csn_test))

  for(i in 1:rn){
    cancer_pairs_matrix[i,1]->type_one
    cancer_pairs_matrix[i,2]->type_two


    new_lable<-vector()
    label_num<-vector()
    for(n in 1:csn){
      if((cnam[n]==type_one)||(cnam[n]==type_two)){
        label_num<-c(label_num,n)
      }

    }
    new_labl<-cnam[label_num]
    new_data<-gdy_filt[,label_num]
    new_labl<-as.factor(new_labl)

    ##Get biomarker gene pairs##
    classifier <- SWAP.Train.KTSP(new_data, new_labl)
    ##Predict the samples##
    #trainingPrediction <- SWAP.KTSP.Classify(gdy_filt, classifier)
    trainingPrediction <- SWAP.KTSP.Classify(braina, classifier)
    tr_ch<-as.character(trainingPrediction)
    tr_ch -> cancer_type_accuracy[i,]
    ktspStatDefault <- SWAP.KTSP.Statistics(inputMat = braina, classifier = classifier)

    kts<-ktspStatDefault$statistics

    classifier$TSPs->clan

    nclan<-nrow(clan)

    ktsa<-abs(ktspStatDefault$statistics/(nclan/2))

    ktsa -> cancer_type_score[i,]

  }

  ncol(braina)->lp

  ma<-array(dim=c(6,550))
  ma<-as.data.frame(ma)
  predict_lable<-vector()
  ww<-1
  csc<-array(dim=c(ctn,lp))
  rownames(csc)<-namtabz



  for(i in 1:lp){
    table(cancer_type_accuracy[,i])->eachsamp
    eachsamp<-as.data.frame(eachsamp)

    eachsamp[,1]<-as.character(eachsamp[,1])

    nrow(eachsamp)->re

    new_score<-array(dim=c(re,2))

    for(pi in 1:re){
      ta<-0
      for(ki in 1:rn){
        if(cancer_type_accuracy[ki,i]==eachsamp[pi,1]){
          ta<-ta+cancer_type_score[ki,i]
        }
      }
      new_score[pi,1]<-eachsamp[pi,1]
      new_score[pi,2]<-ta
    }
    new_score[,2]->tn
    new_score[,1]->tnc
    tnn<-as.numeric(tn)
    new_score[,2]<-tnn

    new_score<-as.data.frame(new_score)
    new_score[,2]<-tnn
    new_score[,1]<-tnc

    nnr<-nrow(new_score)

    ###GET score matrix for each sample###
    for(tt in 1:ctn){
      for(jj in 1:nnr){
        if(new_score[jj,1]==namtabz[tt]){
          csc[tt,i]<-new_score[jj,2]
        }
      }
    }

    ####FINAL RESULT####
    which.max(new_score[,2])->max_numb
    kt<-as.character(new_score[max_numb,1])
    predict_lable<-c(predict_lable,kt)

    which.max(new_score[,2][-which.max(new_score[,2])])->max_secnumb
    pp<-c(max_numb,max_secnumb)
    which.max(new_score[,2][-pp])->max_thrnumb
    ppf<-c(max_numb,max_secnumb,max_thrnumb)
    which.max(new_score[,2][-ppf])->max_founumb
    kt_sec<-as.character(new_score[max_secnumb,1])
    kt_thr<-as.character(new_score[max_thrnumb,1])
    kt_fou<-as.character(new_score[max_founumb,1])

    k_max<-max(new_score[,2])
    tl<-paste(predict_lable[i],k_max,paste(kt_sec,max(new_score[,2][-which.max(new_score[,2])])))
    new_score=new_score[rev(order(new_score[,2])),]
    new_scoret<-t(new_score)

    ###


    #eachsamp

    ma[1,ww]<-cnam[i]
    ma[2,ww]<-predict_lable[i]
    ma[3,ww]<-k_max
    ma[4,ww]<-paste(kt_sec,max(new_score[,2][-which.max(new_score[,2])]))
    ma[5,ww]<-paste(kt_thr,max(new_score[,2][-pp]))
    ma[6,ww]<-paste(kt_fou,max(new_score[,2][-ppf]))
    ww<-ww+1

    tl<-paste(cnam[i],predict_lable[i],k_max,paste(kt_sec,max(new_score[,2][-which.max(new_score[,2])])))

    new_score=new_score[rev(order(new_score[,2])),]
    new_scoret<-t(new_score)
  }


  #########################################
  #Unknown and Intermediate-type#
  #########################################


  new_scoren<-new_score[,2]/ctn
  new_scorea<-new_score
  new_scorea[,2]<-new_scoren
  csc[is.na(csc)] <- 0
  csc_new<-csc/ctn

  new_predict<-vector()
  uncertain_predict<-vector()
  score_predict<-c()
  pvalue<-c()

  for(v in 1:ncol(csc_new)){
    cscn=csc_new[rev(order(csc_new[,v])),v]
    rr<-v
    which.max(csc_new[,rr])->max_a_numb
    max(csc_new[,rr])->max_a

    which.max(csc_new[,rr][-which.max(csc_new[,rr])])->max_b_secnumb
    max(csc_new[,rr][-which.max(csc_new[,rr])])->max_b

    cz<-max_a-max_b
    rownames(csc_new)[max_a_numb]->mn
    rownames(csc_new)[max_b_secnumb]->mnb

    score_predict<-c(score_predict,max_a)

  }

  all_result <- list(predict_lable = predict_lable, predict_score=score_predict)

  return(all_result)


}




#############################
#scDetect feature and cutoff#
#get list results
#1# raw_predict_lable
#2#predict_score #3#pvalue #4#
##############################
#' @title Cell type classification using scDetect
#' @description Predict cell types using scDetect based on training data set.
#' @param vali_set_matrix A matrix object with genes as rows and cells as columns.
#' @param train_set_matrix A matrix object with genes as rows and cells as columns.
#' @param train_set_lable A list object with cell type lables of the cells in train_set_matrix.
#' @param p_value A numeric of the cutoff pvalue.
#' @return A data frame object with four colums (predict_lable, predict_score, pvalue, final_predict_lable).
#' @export
#' @author
#' Yifei Shen
#' @examples
#'
#' # Cell type classification using scDetect
#'
#'
#' prediction_results <- scDetect(vali_set_matrix,train_set_matrix,train_set_lable,feature_list)
#'
#'
scDetect<-function(vali_set_matrix,train_set_matrix,train_set_lable,p_value=NULL){

  if(is.null(p_value)){p_value<-1}

  rns<-intersect(rownames(vali_set_matrix),rownames(train_set_matrix))

  vali_set_matrix<-vali_set_matrix[rns,]
  train_set_matrix<-train_set_matrix[rns,]

  #Generate feature genes#
  print("Generate feature genes")
  feature_list<-getFeature(train_set_matrix,train_set_lable)

  #Generate cutoff value#
  print("Generate cutoff value")
  cutoff_value<-getCutoff(train_set_matrix,train_set_lable,feature_list)

  cut_one<-cutoff_value$unknown_cutoff

  cut_thr<-cutoff_value$two_cell_type_cutoff

  random_score<-cutoff_value$random_score
  ####transfer data####
  if(!is.null(feature_list)){
    cnam<-as.character(train_set_lable)
    gdy_filt<-train_set_matrix[feature_list,]
    braina<-vali_set_matrix[feature_list,]
  }

  if(is.null(feature_list)){

    cnam<-as.character(train_set_lable)
    gdy_filt<-train_set_matrix
    braina<-vali_set_matrix


  }
  #####################

  #cell type number
  namtabz<-as.data.frame(table(train_set_lable))
  namtabz<-namtabz[which(namtabz$Freq!=0),]
  namtabz<-namtabz[,1]
  namtabz<-as.character(namtabz)
  ctn<-length(namtabz)

  #cell sample number
  csn<-length(train_set_lable)
  csn_test<-ncol(vali_set_matrix)

  #make the cell type pairs matrix##
  rn<-ctn*(ctn-1)/2
  cancer_pairs_matrix<-array(dim=c(rn,2))
  row_num<-vector()
  count<-1
  for(i in 1:(ctn-1)){
    namtabz[i]->typea
    numb<-i+1
    for(k in numb:ctn){
      cancer_pairs_matrix[count,1]<-typea
      cancer_pairs_matrix[count,2]<-namtabz[k]
      rnames<-paste(typea,namtabz[k],sep=" VS ")
      row_num<-c(row_num,rnames)
      count<-count+1
    }
  }
  rownames(cancer_pairs_matrix)<-row_num
  #cancer_pairs_matrix
  #make the cell type pairs matrix END##

  #for each cell pairs
  #Cell type prediction#
  print("Cell type prediction based on scDetect")
  cancer_type_accuracy<-array(dim=c(rn,csn_test))
  rownames(cancer_type_accuracy)<-row_num
  cancer_type_score<-array(dim=c(rn,csn_test))

  for(i in 1:rn){
    cancer_pairs_matrix[i,1]->type_one
    cancer_pairs_matrix[i,2]->type_two


    new_lable<-vector()
    label_num<-vector()
    for(n in 1:csn){
      if((cnam[n]==type_one)||(cnam[n]==type_two)){
        label_num<-c(label_num,n)
      }

    }
    new_labl<-cnam[label_num]
    new_data<-gdy_filt[,label_num]
    new_labl<-as.factor(new_labl)

    ##Get biomarker gene pairs##
    classifier <- SWAP.Train.KTSP(new_data, new_labl)

    ##Predict the samples##
    trainingPrediction <- SWAP.KTSP.Classify(braina, classifier)
    tr_ch<-as.character(trainingPrediction)
    tr_ch -> cancer_type_accuracy[i,]
    ktspStatDefault <- SWAP.KTSP.Statistics(inputMat = braina, classifier = classifier)

    kts<-ktspStatDefault$statistics
    classifier$TSPs->clan
    nclan<-nrow(clan)
    ktsa<-abs(ktspStatDefault$statistics/(nclan/2))
    ktsa -> cancer_type_score[i,]

  }


  ncol(braina)->lp

  ma<-array(dim=c(6,550))
  ma<-as.data.frame(ma)
  predict_lable<-vector()
  ww<-1
  csc<-array(dim=c(ctn,lp))
  rownames(csc)<-namtabz



  for(i in 1:lp){
    table(cancer_type_accuracy[,i])->eachsamp
    eachsamp<-as.data.frame(eachsamp)

    eachsamp[,1]<-as.character(eachsamp[,1])

    nrow(eachsamp)->re

    new_score<-array(dim=c(re,2))

    for(pi in 1:re){
      ta<-0
      for(ki in 1:rn){
        if(cancer_type_accuracy[ki,i]==eachsamp[pi,1]){
          ta<-ta+cancer_type_score[ki,i]
        }
      }
      new_score[pi,1]<-eachsamp[pi,1]
      new_score[pi,2]<-ta
    }
    new_score[,2]->tn
    new_score[,1]->tnc
    tnn<-as.numeric(tn)
    new_score[,2]<-tnn

    new_score<-as.data.frame(new_score)
    new_score[,2]<-tnn
    new_score[,1]<-tnc

    nnr<-nrow(new_score)

    ###GET score matrix for each sample###
    for(tt in 1:ctn){
      for(jj in 1:nnr){
        if(new_score[jj,1]==namtabz[tt]){
          csc[tt,i]<-new_score[jj,2]
        }
      }
    }

    ####FINAL RESULT####
    which.max(new_score[,2])->max_numb
    kt<-as.character(new_score[max_numb,1])
    predict_lable<-c(predict_lable,kt)
    which.max(new_score[,2][-which.max(new_score[,2])])->max_secnumb
    pp<-c(max_numb,max_secnumb)
    which.max(new_score[,2][-pp])->max_thrnumb
    ppf<-c(max_numb,max_secnumb,max_thrnumb)
    which.max(new_score[,2][-ppf])->max_founumb
    kt_sec<-as.character(new_score[max_secnumb,1])
    kt_thr<-as.character(new_score[max_thrnumb,1])
    kt_fou<-as.character(new_score[max_founumb,1])

    k_max<-max(new_score[,2])
    tl<-paste(predict_lable[i],k_max,paste(kt_sec,max(new_score[,2][-which.max(new_score[,2])])))
    new_score=new_score[rev(order(new_score[,2])),]
    new_scoret<-t(new_score)

    ma[1,ww]<-cnam[i]
    ma[2,ww]<-predict_lable[i]
    ma[3,ww]<-k_max
    ma[4,ww]<-paste(kt_sec,max(new_score[,2][-which.max(new_score[,2])]))
    ma[5,ww]<-paste(kt_thr,max(new_score[,2][-pp]))
    ma[6,ww]<-paste(kt_fou,max(new_score[,2][-ppf]))
    ww<-ww+1

    tl<-paste(cnam[i],predict_lable[i],k_max,paste(kt_sec,max(new_score[,2][-which.max(new_score[,2])])))

    new_score=new_score[rev(order(new_score[,2])),]
    new_scoret<-t(new_score)
  }


  #########################################
  #Unknown and  Intermediate-type#
  #########################################

  new_scoren<-new_score[,2]/ctn

  new_scorea<-new_score

  new_scorea[,2]<-new_scoren

  csc[is.na(csc)] <- 0

  csc_new<-csc/ctn


  new_predict<-vector()
  uncertain_predict<-vector()
  score_predict<-c()
  pvalue<-c()

  for(v in 1:ncol(csc_new)){
    cscn=csc_new[rev(order(csc_new[,v])),v]

    rr<-v
    which.max(csc_new[,rr])->max_a_numb
    max(csc_new[,rr])->max_a

    length(which(random_score>=max_a))/length(random_score)->pvaluex
    pvalue<-c(pvalue,pvaluex)

    which.max(csc_new[,rr][-which.max(csc_new[,rr])])->max_b_secnumb
    max(csc_new[,rr][-which.max(csc_new[,rr])])->max_b

    cz<-max_a-max_b

    rownames(csc_new)[max_a_numb]->mn
    rownames(csc_new)[max_b_secnumb]->mnb

    score_predict<-c(score_predict,max_a)

    if(pvaluex<=p_value){
      #if(cz>cut_thr){
        new_predict<-c(new_predict,mn)
      #}

      #if(cz<=cut_thr){
      #  new_predict<-c(new_predict,"Intermediate-type")
      #}
    }

    if(pvaluex>p_value){
      new_predict<-c(new_predict,"Unknown")
    }


  }


  #all_result <- list(raw_predict_lable = predict_lable, predict_score=score_predict, pvalue=pvalue, final_predict = new_predict)
  all_result<-cbind(predict_lable,score_predict,pvalue,new_predict)
  rownames(all_result)<-colnames(vali_set_matrix)
  colnames(all_result)<-c("predict_lable","predict_score","pvalue","final_predict_lable")
  all_result<-as.data.frame(all_result)
  all_result$predict_lable<-as.character(all_result$predict_lable)
  all_result$final_predict_lable<-as.character(all_result$final_predict_lable)
  all_result$predict_score<-as.numeric(as.character(all_result$predict_score))
  all_result$pvalue<-as.numeric(as.character(all_result$pvalue))
  return(all_result)


}




############################
#calculate Epithelial score#
############################
#' @title Get epithelial score of each cell
#' @description Get epithelial score of each cell based on \code{AUCell}.
#' @param data_matrix A matrix object with genes as rows and cells as columns.
#' @param gene_list A vector object with the epithelial related genes.
#' @return A vector object with the epithelial of each cell.
#' @export
#' @author
#' Yifei Shen
#' @examples
#'
#' # Get epithelial score of each cell
#'
#'
#' epithelial_score <- get_epithelial_score(data_matrix,gene_list)
#'

get_epithelial_score<-function(data_matrix,gene_list){

  library(AUCell)
  ##AUCell
  ea<-data_matrix
  bgenes<-gene_list
  #wg<-intersect(gene_list,rownames(data_matrix))
  #bgenes<-wg

  cells_rankings <- AUCell_buildRankings(ea,plotStats = F)
  geneSets <- list(Epithelial=bgenes)
  cells_AUC <- AUCell_calcAUC(geneSets, cells_rankings, aucMaxRank=nrow(cells_rankings)*0.05)

  pdac_auc<-cells_AUC@assays@data@listData$AUC
  t(pdac_auc)->pdac_auc

  pdac_auc<-as.data.frame(pdac_auc)
  epithelial_score<-pdac_auc
  return(epithelial_score)

}



###################################################
#calculate CNV results based on CNV and clustering#
###################################################
#' @title Generate CNV classification results based on CNV consensus clustering
#' @description Get epithelial score of each cell based on \code{AUCell}.
#' @param data_matrix A matrix object with genes as rows and cells as columns.
#' @param gene_list A vector  object with the epithelial related genes.
#' @param anno_file_input A data frame object of the cell type prediction results based on scDetect.
#' @param gene_list A list object with the epithelial related genes used for epithelial score calculation.
#' @param output_dir A character object with the output directory.
#' @return A data frame object with "CNV_Class","CNV_entropy_score","anno_file".
#'
#' @author
#' Yifei Shen
#' @examples
#'
#' # Generate CNV classification results based on CNV consensus clustering
#'
#'
#' cnv_results <- get_cnv_score(data_matrix,gene_position_file,anno_file_input,output_dir)
#'
#'

get_cnv_score<-function(data_matrix,gene_position_file,anno_file_input,output_dir){

  library(infercnv)

  genet<-gene_position_file
  exp_ran<-data_matrix
  anno_file_ran<-anno_file_input
  gene_d<-rownames(exp_ran)
  gene_ol<-intersect(genet[,4],gene_d)
  genet_n<-genet[which(genet[,4] %in% gene_ol),]
  exp_gene<-exp_ran[as.character(genet_n[,4]),]
  gene_file<-genet_n
  rownames(gene_file)<-gene_file[,4]
  gene_file<-gene_file[,-4]


  infercnv_obj <- infercnv::CreateInfercnvObject(raw_counts_matrix=exp_gene,
                                                 gene_order_file=gene_file,
                                                 annotations_file=anno_file_ran,
                                                 ref_group_names=c("Tcell"))


  out_dir<-paste(output_dir,"\\infercnv\\",sep="")
  infercnv_obj_default = infercnv::run(
    infercnv_obj,
    cutoff=1, # cutoff=1 works well for Smart-seq2, and cutoff=0.1 works well for 10x Genomics
    out_dir=out_dir,
    cluster_by_groups=TRUE,
    plot_steps=FALSE,
    denoise=TRUE,
    HMM=FALSE,
    no_prelim_plot=TRUE,
    png_res=60
  )


  ##entropy normalization
  cnv_matrix<-infercnv_obj_default@expr.data
  cnv_matrix_new<-cnv_matrix

  for(k in 1:ncol(cnv_matrix_new)){
    cnv_matrix_new[,k]<-cnv_matrix_new[,k]/sum(cnv_matrix_new[,k])
  }
  cnv_matrix_new->cnv_matrix

  ##entropy##

  test.entropy <- function(d){

    #print(d)
    res <- 0
    for(i in 1:length(d))
    {
      if(d[i]!=0)
        res <- res + d[i]*log(d[i])
    }
    return (-res)
  }

  tenl<-c()
  for(i in 1:ncol(cnv_matrix)){
    as.numeric(cnv_matrix[,i])->pk
    ten<-test.entropy(pk)
    tenl<-c(tenl,ten)
  }
  tenl<-cbind(tenl,anno_file_ran)
  colnames(tenl)[1]<-"entropy_score"

  ##########################

  ####consense clustering####

  library(ConsensusClusterPlus)


  d<-infercnv_obj_default@expr.data

  d = sweep(d,1, apply(d,1,median,na.rm=T))
  title<-paste(output_dir,"cluster\\",sep="")
  results = ConsensusClusterPlus(d,maxK=6,reps=50,pItem=0.8,pFeature=1, title=title,clusterAlg="km",distance="euclidean",seed=1262118388.71279,plot="png")
  icl = calcICL(results,title=title,plot="png")
  ccs<-icl[["clusterConsensus"]]

  ccs<-na.omit(ccs)
  k<-6
  k_cons<-c()
  kid<-c()
  for(i in 2:k){
    #i<-2
    avek<-mean(ccs[which(ccs[,1]==i),3])
    k_cons<-c(k_cons,avek)
    kid<-c(kid,i)
  }

  k_cons_new<-cbind(kid,k_cons)
  kmaxid<-k_cons_new[which.max(k_cons_new[,2]),1]

  csr<-cbind(results[[kmaxid]][["consensusClass"]],tenl)
  csr<-as.data.frame(csr)
  colnames(csr)<-c("CNV_Class","CNV_entropy_score","anno_file")

  cluster_entropy<-c()
  for( w in 1:kmaxid){

    cluster_x<-mean(csr$CNV_entropy_score[which(csr$CNV_Class==w)])
    cluster_entropy<-c(cluster_entropy,cluster_x)
  }

  tcid<-which.max(cluster_entropy)

  csr$CNV_Class[which(csr$CNV_Class!=tcid)]<-"Tumor"
  csr$CNV_Class[which(csr$CNV_Class==tcid)]<-"Other"

  return(csr)



}


####################################
#scDetect_Cancer## all combine code#
#results #list: lable; detail_info#
####################################
##############################
#' @title Cell type classification using scDetect-Cancer in tumor scRNA-Seq data
#' @description Predict cell types using scDetect-Canaer based on reference training data set.
#' @param vali_set_matrix A matrix object with genes as rows and cells as columns.
#' @param train_set_matrix A matrix object with genes as rows and cells as columns.
#' @param train_set_lable A list object with cell type lables of the cells in train_set_matrix.
#' @param gene_position_file A data frame object of gene position with four colums (Chromosome, Start_postition, End_position, Gene_symbol).
#' @param gene_list A list object with the epithelial related genes used for epithelial score calculation.
#' @param output_dir A character object with the output directory.
#' @return A list object with a vector "lable" of the prediction cell type, and a data frame "detail_info" of the detailed information.
#' @export
#' @author
#' Yifei Shen
#' @examples
#'
#' # Cell type classification using scDetect-Cancer in tumor scRNA-Seq data
#'
#'
#' prediction_cancer_results <- scDetect_Cancer(vali_set_matrix,train_set_matrix,train_set_lable,gene_position_file,gene_list,output_dir)
#'
#'
scDetect_Cancer<-function(vali_set_matrix,train_set_matrix,train_set_lable,gene_position_file,gene_list,output_dir){


  mela_matrix<-train_set_matrix
  mela_lable<-train_set_lable

  mela_matrix_all<-vali_set_matrix


  #gene_list<-read.table(gene_list, header = F)

  #gene_list<-as.character(gene_list[,1])

  #gene_position_file--cnv
  #gene_position_file<-read.table(gene_position_file)



  ##############################################
  ###predict immune T cell using scDetect###
  print("Predict Immune normal reference cells using scDetect")

  predict_results<-scDetect(mela_matrix_all,mela_matrix,mela_lable)

  result_a<-cbind(colnames(mela_matrix_all),predict_results$predict_lable,predict_results$predict_score)
  result_a<-as.data.frame(result_a)
  result_a[,2]<-as.character(result_a[,2])
  result_a[,3]<-as.numeric(as.character(result_a[,3]))

  result_b<-result_a[which(result_a[,2] =="Tcell"),]

  median_score<-median(result_b[,3])

  result_c<-cbind(result_a,result_a[,2])

  colnames(result_c)<-c("sample_ID","predict_lable","predict_score","normal_other")
  result_c$normal_other<-as.character(result_c$normal_other)
  result_c$predict_lable<-as.character(result_c$predict_lable)
  result_c$normal_other[which(result_c$predict_lable!="Tcell")]<-"Other"

  result_c$predict_score<-as.numeric(as.character(result_c$predict_score))
  result_c$normal_other[which(result_c$predict_score > median_score)]<-"Other"

  anno_file<-result_c$normal_other
  anno_file<-as.data.frame(anno_file)
  rownames(anno_file)<-as.character(result_c$sample_ID)

  ##############################################


  ##############################################
  ###cnv analysis
  print("CNV consensus clustering")
  gene_position_file<-gene_position_file
  output_dir<-output_dir

  anno_file_input<-anno_file
  data_matrix<-mela_matrix_all

  cnv_results<-get_cnv_score(data_matrix,gene_position_file,anno_file_input,output_dir)

  ##############################################



  ##############################################
  ###epithelial analysis
  print("Epithelial origin analysis")
  data_matrix<-mela_matrix_all
  gene_list<-gene_list


  epithelial_results<-get_epithelial_score(data_matrix,gene_list)

  ##############################################



  ##############################################
  #combine all data#
  csr<-cnv_results
  scr_es<-cbind(csr,epithelial_results)
  scr_es_an<-cbind(scr_es,anno_file)
  score_t<-scr_es_an$Epithelial[which(scr_es_an$anno_file=="Tcell")]
  sctt<-t.test(score_t,alternative = "less",mu=0.35)

  sctp<-c()
  sctl<-c()

  for(i in 1:nrow(scr_es_an)){

    sctt<-t.test(score_t,alternative = "less",mu=scr_es_an$Epithelial[i])

    sctp<-c(sctp,sctt$p.value)

    if(sctt$p.value<=1e-10){

      sctl<-c(sctl,"Tumor")

    }else{

      sctl<-c(sctl,"Other")

    }

  }


  scr_es_an_p<-cbind(scr_es_an,sctp,sctl)
  final_results<-cbind(scr_es_an_p,predict_results$final_predict)
  final_results<-final_results[,-5]
  colnames(final_results)[4:7]<-c("Epithelial_score","Epithelial_pvalue","Epithelial_class","raw_lable")
  final_lable<-final_results$raw_lable
  final_results<-cbind(final_results,final_lable)
  final_results$final_lable<-as.character(final_results$final_lable)
  final_results$final_lable[intersect(which(final_results$CNV_Class=="Tumor"),which(final_results$Epithelial_class=="Tumor"))]<-"Tumor"



  tta<-which(final_results$CNV_Class=="Tumor")
  ttb<-intersect(tta,which(final_results$raw_lable=="Unknown"))

  if(length(ttb>0)){
    final_results$final_lable[ttb]<-"Tumor"
  }


  tta<-which(final_results$CNV_Class=="Other")
  ttb<-intersect(tta,which(final_results$Epithelial_class=="Tumor"))

  if(length(ttb>0)){
    final_results$final_lable[ttb]<-"Unknown"
  }


  all_results<-list(lable=final_results$final_lable,detail_info=final_results)

  return(all_results)

}




################################
#evaluate function for F1 score#
################################
#' @title Evaluate the classification results
#' @description Evaluate the classification results for \code{scDetect} based on predicted cell type and true cell type.
#' @param vali_set_lable A vector object with the epithelial related genes.
#' @param gene_list A vector object with the true cell type lable.
#' @return A list object with Conf = Confusion_matrix, MedF1 = Median_F1_score, F1 = F1_score, Acc = Accuracy, PercUnl = Unlabled_cell_percentage, PopSize = Population_size.
#' @export
#' @author
#' Yifei Shen
#' @examples
#'
#' # Evaluate the classification results
#'
#'
#' evaluate_results <- evaluate(vali_set_lable,predict_lable)
#'

evaluate <- function(vali_set_lable,predict_lable, Indices = NULL){
  "
  Script to evaluate the performance of the classifier.
  It returns multiple evaluation measures: the confusion matrix, median F1-score, F1-score for each class, accuracy, percentage of unlabeled, population size.

  The percentage of unlabeled cells is find by checking for cells that are labeled 'Unassigned', 'unassigned', 'Unknown', 'unknown', 'Nodexx', 'rand', or 'ambiguous'.

  Parameters
  ----------
  TrueLabelsPath: csv file with the true labels (format: one column, no index)
  PredLabelsPath: csv file with the predicted labels (format: one column, no index)
  Indices: which part of the csv file should be read (e.g. if more datasets are tested at the same time) (format: c(begin, end))

  Returns
  -------
  Conf: confusion matrix
  MedF1 : median F1-score
  F1 : F1-score per class
  Acc : accuracy
  PercUnl : percentage of unlabeled cells
  PopSize : number of cells per cell type
  "

  us<-which(vali_set_lable=="Unassigned")

  if(length(us!=0)){

    predict_lable_u<-predict_lable[-us]
    vali_set_lable_u<-vali_set_lable[-us]

  }else{

    predict_lable_u<-predict_lable
    vali_set_lable_u<-vali_set_lable

  }



  true_lab <- vali_set_lable_u
  pred_lab <- predict_lable_u

  if (! is.null(Indices)){
    true_lab <- true_lab[Indices]
    pred_lab <- pred_lab[Indices]
  }

  unique_true <- unlist(unique(true_lab))
  unique_pred <- unlist(unique(pred_lab))

  unique_all <- unique(c(unique_true,unique_pred))
  conf <- table(true_lab,pred_lab)
  pop_size <- rowSums(conf)

  pred_lab = gsub('Node..','Node',pred_lab)

  conf_F1 <- table(true_lab,pred_lab,exclude = c('unassigned','Unassigned','Unknown','rand','Node','ambiguous','unknown','Two-cancer-type','Intermediate-type'))

  #conf_F1 <- table(true_lab,pred_lab,exclude = c('unassigned','Unassigned','Unknown','rand','Node','ambiguous','unknown'))

  F1 <- vector()
  sum_acc <- 0

  for (i in c(1:length(unique_true))){
    #i<-2
    #print(i)
    findLabel = colnames(conf_F1) == row.names(conf_F1)[i]
    #if(sum(findLabel)){
    prec <- conf_F1[i,findLabel] / colSums(conf_F1)[findLabel]
    rec <- conf_F1[i,findLabel] / rowSums(conf_F1)[i]

    if(length(prec)==0 || length(rec)==0){
      F1[i]=NA
      next

    }

    if (prec == 0 || rec == 0){
      F1[i] = 0
    } else{
      F1[i] <- (2*prec*rec) / (prec + rec)
    }
    sum_acc <- sum_acc + conf_F1[i,findLabel]
    #} else {
    #  F1[i] = 0
    #}
  }

  #F1<-na.omit(F1)



  pop_size <- pop_size[pop_size > 0]

  names(F1) <- names(pop_size)

  F1<-na.omit(F1)

  med_F1 <- median(F1)

  total <- length(pred_lab)
  num_unlab <- sum(pred_lab == 'unassigned') + sum(pred_lab == 'Unassigned') + sum(pred_lab == 'rand') + sum(pred_lab == 'Unknown') + sum(pred_lab == 'unknown') + sum(pred_lab == 'Node') + sum(pred_lab == 'ambiguous')
  per_unlab <- num_unlab / total

  acc <- sum_acc/sum(conf_F1)

  result <- list(Conf = conf, MedF1 = med_F1, F1 = F1, Acc = acc, PercUnl = per_unlab, PopSize = pop_size)

  return(result)
}






